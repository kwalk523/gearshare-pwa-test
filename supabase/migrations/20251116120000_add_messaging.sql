-- Messaging schema: secure 1:1 conversations, RLS, blocks, and reports
-- Note: Requires pgcrypto/gen_random_uuid; Supabase includes this by default.

-- Conversations (supports 1:1 for now via is_direct)
create table if not exists public.conversations (
  id uuid primary key default gen_random_uuid(),
  is_direct boolean not null default true,
  created_at timestamptz not null default now()
);

-- Participants
create table if not exists public.conversation_participants (
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  profile_id uuid not null references public.profiles(id) on delete cascade,
  last_read_at timestamptz,
  created_at timestamptz not null default now(),
  primary key (conversation_id, profile_id)
);

-- Messages
create table if not exists public.messages (
  id bigint generated by default as identity primary key,
  conversation_id uuid not null references public.conversations(id) on delete cascade,
  sender_id uuid not null references public.profiles(id) on delete cascade,
  content text not null check (char_length(content) <= 2000),
  is_deleted boolean not null default false,
  is_flagged boolean not null default false,
  created_at timestamptz not null default now()
);

-- Block list
create table if not exists public.blocked_users (
  blocker_id uuid not null references public.profiles(id) on delete cascade,
  blocked_id uuid not null references public.profiles(id) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (blocker_id, blocked_id)
);

-- Message reports
create table if not exists public.message_reports (
  id bigint generated by default as identity primary key,
  message_id bigint not null references public.messages(id) on delete cascade,
  reporter_id uuid not null references public.profiles(id) on delete cascade,
  reason text,
  details text,
  created_at timestamptz not null default now()
);

-- Optional: simple banned words table for server-side flagging
create table if not exists public.banned_words (
  pattern text primary key
);

-- Seed with a neutral placeholder word; customize in production
insert into public.banned_words(pattern)
values ('badword')
on conflict do nothing;

-- Trigger to auto-flag messages that match any banned pattern (case-insensitive)
create or replace function public.flag_message_if_banned()
returns trigger
language plpgsql
as $$
declare
  bw text;
begin
  for bw in select pattern from public.banned_words loop
    if new.content ilike '%' || bw || '%' then
      new.is_flagged := true;
      exit;
    end if;
  end loop;
  return new;
end;
$$;

drop trigger if exists trg_flag_message on public.messages;
create trigger trg_flag_message
before insert on public.messages
for each row
execute function public.flag_message_if_banned();

-- RLS
alter table public.conversations enable row level security;
alter table public.conversation_participants enable row level security;
alter table public.messages enable row level security;
alter table public.blocked_users enable row level security;
alter table public.message_reports enable row level security;

-- Policies
-- Conversations: participants can select; prevent direct inserts/updates/deletes by clients
drop policy if exists "Convo: participants can view" on public.conversations;
create policy "Convo: participants can view"
on public.conversations for select
to authenticated
using (
  exists (
    select 1 from public.conversation_participants cp
    where cp.conversation_id = conversations.id and cp.profile_id = auth.uid()
  )
);

drop policy if exists "Convo: no direct writes" on public.conversations;
create policy "Convo: no direct writes"
on public.conversations for all
to authenticated
using (false) with check (false);

-- Participants: only see rows for your conversations; writes are managed by RPC
drop policy if exists "Participants: view own convos" on public.conversation_participants;
create policy "Participants: view own convos"
on public.conversation_participants for select
to authenticated
using (profile_id = auth.uid());

drop policy if exists "Participants: no client writes" on public.conversation_participants;
create policy "Participants: no client writes"
on public.conversation_participants for all
to authenticated
using (false) with check (false);

-- Messages: select if you are participant in the conversation
drop policy if exists "Messages: participants can read" on public.messages;
create policy "Messages: participants can read"
on public.messages for select
to authenticated
using (
  exists (
    select 1 from public.conversation_participants cp
    where cp.conversation_id = messages.conversation_id and cp.profile_id = auth.uid()
  )
);

-- Messages: insert only for participants, sender must be auth.uid(),
-- must be connected (accepted) and not blocked either way
drop policy if exists "Messages: participants can send if connected and not blocked" on public.messages;
create policy "Messages: participants can send if connected and not blocked"
on public.messages for insert
to authenticated
with check (
  sender_id = auth.uid()
  and exists (
    select 1 from public.conversation_participants cp
    where cp.conversation_id = messages.conversation_id and cp.profile_id = auth.uid()
  )
  and exists (
    -- ensure the other participant has accepted connection with sender
    select 1
    from public.conversation_participants cp_self
    join public.conversation_participants cp_other
      on cp_self.conversation_id = cp_other.conversation_id
    join public.profile_connections pc
      on (
        pc.status = 'accepted'
        and ((pc.requester_id = cp_self.profile_id and pc.addressee_id = cp_other.profile_id)
          or (pc.requester_id = cp_other.profile_id and pc.addressee_id = cp_self.profile_id))
      )
    where cp_self.conversation_id = messages.conversation_id
      and cp_self.profile_id = auth.uid()
      and cp_other.profile_id <> auth.uid()
  )
  and not exists (
    -- block in either direction
    select 1
    from public.conversation_participants cp_self
    join public.conversation_participants cp_other
      on cp_self.conversation_id = cp_other.conversation_id
    join public.blocked_users b
      on (
        (b.blocker_id = cp_self.profile_id and b.blocked_id = cp_other.profile_id)
        or (b.blocker_id = cp_other.profile_id and b.blocked_id = cp_self.profile_id)
      )
    where cp_self.conversation_id = messages.conversation_id
      and cp_self.profile_id = auth.uid()
      and cp_other.profile_id <> auth.uid()
  )
);

-- Messages: allow sender to soft-delete (update is_deleted) their own messages
drop policy if exists "Messages: sender can soft-delete" on public.messages;
create policy "Messages: sender can soft-delete"
on public.messages for update
to authenticated
using (sender_id = auth.uid())
with check (sender_id = auth.uid());

-- Blocked: manage your own block list
drop policy if exists "Blocked: read own blocks" on public.blocked_users;
create policy "Blocked: read own blocks"
on public.blocked_users for select
to authenticated
using (blocker_id = auth.uid());

drop policy if exists "Blocked: manage own blocks" on public.blocked_users;
create policy "Blocked: manage own blocks"
on public.blocked_users for insert
to authenticated
with check (blocker_id = auth.uid());

drop policy if exists "Blocked: unblock self" on public.blocked_users;
create policy "Blocked: unblock self"
on public.blocked_users for delete
to authenticated
using (blocker_id = auth.uid());

-- Reports: users can report any message they can read
drop policy if exists "Reports: insert if can read" on public.message_reports;
create policy "Reports: insert if can read"
on public.message_reports for insert
to authenticated
with check (
  reporter_id = auth.uid()
  and exists (
    select 1 from public.messages m
    join public.conversation_participants cp
      on cp.conversation_id = m.conversation_id and cp.profile_id = auth.uid()
    where m.id = message_reports.message_id
  )
);

drop policy if exists "Reports: read own" on public.message_reports;
create policy "Reports: read own"
on public.message_reports for select
to authenticated
using (reporter_id = auth.uid());

-- Helper RPC: create or get a direct conversation with another user you are connected to
create or replace function public.create_or_get_direct_conversation(other_id uuid)
returns uuid
language plpgsql
security definer
set search_path = public
as $$
declare
  self_id uuid := auth.uid();
  convo_id uuid;
begin
  if other_id is null or self_id is null then
    raise exception 'Invalid participants';
  end if;
  if other_id = self_id then
    raise exception 'Cannot message yourself';
  end if;

  -- must be connected
  if not exists (
    select 1 from public.profile_connections pc
    where pc.status = 'accepted'
      and ((pc.requester_id = self_id and pc.addressee_id = other_id)
        or (pc.requester_id = other_id and pc.addressee_id = self_id))
  ) then
    raise exception 'You can only message accepted connections';
  end if;

  -- must not be blocked either way
  if exists (
    select 1 from public.blocked_users b
    where (b.blocker_id = self_id and b.blocked_id = other_id)
       or (b.blocker_id = other_id and b.blocked_id = self_id)
  ) then
    raise exception 'Messaging is blocked between these users';
  end if;

  -- find existing direct conversation with exactly these two participants
  select c.id into convo_id
  from public.conversations c
  join public.conversation_participants p1 on p1.conversation_id = c.id and p1.profile_id = self_id
  join public.conversation_participants p2 on p2.conversation_id = c.id and p2.profile_id = other_id
  where c.is_direct = true
  limit 1;

  if convo_id is not null then
    return convo_id;
  end if;

  -- create new conversation and participants
  insert into public.conversations (is_direct) values (true) returning id into convo_id;
  insert into public.conversation_participants (conversation_id, profile_id) values (convo_id, self_id);
  insert into public.conversation_participants (conversation_id, profile_id) values (convo_id, other_id);
  return convo_id;
end;
$$;

revoke all on function public.create_or_get_direct_conversation(uuid) from public;
grant execute on function public.create_or_get_direct_conversation(uuid) to authenticated;
