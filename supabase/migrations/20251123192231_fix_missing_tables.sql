-- Fix missing tables and RLS policies for messaging and core functionality

-- Ensure conversations table exists with proper RLS
CREATE TABLE IF NOT EXISTS public.conversations (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  is_direct boolean NOT NULL DEFAULT true,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Ensure conversation_participants table exists 
CREATE TABLE IF NOT EXISTS public.conversation_participants (
  conversation_id uuid NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
  profile_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  last_read_at timestamptz,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (conversation_id, profile_id)
);

-- Ensure messages table exists with proper structure
CREATE TABLE IF NOT EXISTS public.messages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  conversation_id uuid NOT NULL REFERENCES public.conversations(id) ON DELETE CASCADE,
  sender_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  content text NOT NULL CHECK (char_length(content) <= 2000),
  is_deleted boolean NOT NULL DEFAULT false,
  is_flagged boolean NOT NULL DEFAULT false,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Ensure blocked_users table exists
CREATE TABLE IF NOT EXISTS public.blocked_users (
  blocker_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  blocked_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  created_at timestamptz NOT NULL DEFAULT now(),
  PRIMARY KEY (blocker_id, blocked_id)
);

-- RLS Policies for conversations
ALTER TABLE public.conversations ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their own conversations" ON public.conversations;
CREATE POLICY "Users can view their own conversations" ON public.conversations FOR SELECT
USING (
  auth.uid() IN (
    SELECT profile_id FROM public.conversation_participants WHERE conversation_id = conversations.id
  )
);

DROP POLICY IF EXISTS "Users can create conversations" ON public.conversations;
CREATE POLICY "Users can create conversations" ON public.conversations FOR INSERT
WITH CHECK (auth.uid() IS NOT NULL);

-- RLS Policies for conversation_participants
ALTER TABLE public.conversation_participants ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view conversation participants" ON public.conversation_participants;
CREATE POLICY "Users can view conversation participants" ON public.conversation_participants FOR SELECT
USING (
  profile_id = auth.uid() OR 
  conversation_id IN (
    SELECT conversation_id FROM public.conversation_participants WHERE profile_id = auth.uid()
  )
);

DROP POLICY IF EXISTS "Users can join conversations" ON public.conversation_participants;
CREATE POLICY "Users can join conversations" ON public.conversation_participants FOR INSERT
WITH CHECK (profile_id = auth.uid());

DROP POLICY IF EXISTS "Users can update their participation" ON public.conversation_participants;
CREATE POLICY "Users can update their participation" ON public.conversation_participants FOR UPDATE
USING (profile_id = auth.uid());

-- RLS Policies for messages
ALTER TABLE public.messages ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view messages in their conversations" ON public.messages;
CREATE POLICY "Users can view messages in their conversations" ON public.messages FOR SELECT
USING (
  conversation_id IN (
    SELECT conversation_id FROM public.conversation_participants WHERE profile_id = auth.uid()
  )
);

DROP POLICY IF EXISTS "Users can send messages" ON public.messages;
CREATE POLICY "Users can send messages" ON public.messages FOR INSERT
WITH CHECK (
  sender_id = auth.uid() AND
  conversation_id IN (
    SELECT conversation_id FROM public.conversation_participants WHERE profile_id = auth.uid()
  )
);

DROP POLICY IF EXISTS "Users can update their own messages" ON public.messages;
CREATE POLICY "Users can update their own messages" ON public.messages FOR UPDATE
USING (sender_id = auth.uid());

-- RLS Policies for blocked_users
ALTER TABLE public.blocked_users ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Users can view their blocks" ON public.blocked_users;
CREATE POLICY "Users can view their blocks" ON public.blocked_users FOR SELECT
USING (blocker_id = auth.uid());

DROP POLICY IF EXISTS "Users can block others" ON public.blocked_users;
CREATE POLICY "Users can block others" ON public.blocked_users FOR INSERT
WITH CHECK (blocker_id = auth.uid());

DROP POLICY IF EXISTS "Users can unblock others" ON public.blocked_users;
CREATE POLICY "Users can unblock others" ON public.blocked_users FOR DELETE
USING (blocker_id = auth.uid());

-- Create the RPC function for creating/getting conversations
CREATE OR REPLACE FUNCTION create_or_get_direct_conversation(other_id uuid)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  my_id uuid := auth.uid();
  conversation_uuid uuid;
BEGIN
  -- Check if a direct conversation already exists
  SELECT c.id INTO conversation_uuid
  FROM conversations c
  WHERE c.is_direct = true
  AND c.id IN (
    SELECT cp1.conversation_id
    FROM conversation_participants cp1
    WHERE cp1.profile_id = my_id
    INTERSECT
    SELECT cp2.conversation_id
    FROM conversation_participants cp2
    WHERE cp2.profile_id = other_id
  );

  -- If no conversation exists, create one
  IF conversation_uuid IS NULL THEN
    INSERT INTO conversations (is_direct)
    VALUES (true)
    RETURNING id INTO conversation_uuid;

    -- Add both participants
    INSERT INTO conversation_participants (conversation_id, profile_id)
    VALUES 
      (conversation_uuid, my_id),
      (conversation_uuid, other_id);
  END IF;

  RETURN conversation_uuid;
END;
$$;

-- Grant necessary permissions
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT ALL ON public.conversations TO authenticated;
GRANT ALL ON public.conversation_participants TO authenticated;
GRANT ALL ON public.messages TO authenticated;
GRANT ALL ON public.blocked_users TO authenticated;
